- Banco de dados de Grafos
Os grafos são bons para mostrar relacionamentos - por exemplo, em e-commerce é muito comum mostrar "quem comprou este
produto também comprou aquele produto". (sistema de recomendação)

Entidades = nós
Relacionamentos entre entidades = arestas

Redes sociais são outra boa representação de grafos (pessoas e amizades)
Grafos também servem para determinar o caminho mínimo (esquinas = vértice, rua=aresta, atributo da rua seriam os metros)

Neo4J
Linguagem Cypher

1 CREATE(dylan:Musico {nome: 'Bob Dylan', data_de_nascimento: '1941-05-24' } )
1 CREATE(hendrix:Musico {nome: 'Jimi Hendrix' } )
1 CREATE(al_along:Musica {nome: 'All Along the Watchtower' } )
1 MATCH(hendrix:Musico{nome: 'Jimi Hendrix'}),(al_along:Musica{nome:"All Along the Watchtower"})
2 CREATE(hendrix)-[r:GRAVOU]->(al_along)

SHIFT + ENTER PARA inserir 2 linhas
MATCH é uma consulta no banco

- CONSULTAS
MATCH  = SQL FROM 
RETURN = SQL SELECT

MATCH (m:Musico) RETURN m.nome
MATCH (m:Musico) RETURN m
MATCH (m) RETURN m
MATCH (m:Musico) Where m.nome = 'Bob Dylan' RETURN m
MATCH (m:Musico {nome: 'Bob Dylan'}) RETURN m

MATCH(m:Musico {nome: 'Bob Dylan'}), (al:Musica {nome: 'All Along the Watchtower'}) CREATE(m)-[r:GRAVOU]->(al) CREATE(m)-[s:COMPOS]->(al)
//TODOS OS NÓS
MATCH (n1)-[]-() RETURN n1
//TODOS OS NÓS COM ARESTAS CONVERGINDO PARA ELE
MATCH (n1)<-[]-() RETURN n1
//TODOS OS NÓS COM ARESTAS SAINDO DELE
MATCH (n1)-[]->() RETURN n1
//PARA CONTAR
MATCH (n1)-[]->() RETURN count(n1)
//TODOS OS RELACIONAMENTOS DO BANCO - musicos para musicas
MATCH(n1:Musico)-[r]-(n2:Musica) RETURN n1, type(r), n2
//MOSTRA SÓ OS RELACIONAMENTOS GRAVOU
MATCH(n1:Musico)-[r:GRAVOU]-(n2:Musica) RETURN n1, type(r), n2

EXCLUIR E EDITAR
MATCH(h:Musico {nome: 'Jimi Hendrix'}) SET h.data_de_nascimento = '1942-11-27'
MATCH(h:Musico {nome: 'Jimi Hendrix'}) SET h.data_de_nascimento = null
MATCH(h:Musico {nome: 'Jimi Hendrix'}) DELETE h
//não dá para deletar o Jimi Handrix por que ele participa de um relacionamento
MATCH(h:Musico {nome: 'Jimi Hendrix'})-[r]-() RETURN h, type(r)
//ele tem somente o relacionamento GRAVOU
MATCH(h:Musico {nome: 'Jimi Hendrix'})-[r]-() DELETE r
MATCH(h:Musico {nome: 'Jimi Hendrix'}) DELETE h
//DELETAR TODO O BANCO DE DADOS
MATCH (n) OPTIONAL MATCH (n)-[rel]-() DELETE rel, n

CRIANDO SCRIPTS NO NEO4J - PART I
é possível inserir comandos CREATE num arquivo txt. O neo4j irá processar este arquivo
Se houver a possibilidade de dados duplicados, usa-se o comando MERGE
MERGE (n1:Musico {nome: 'Bob Dylan'})
MERGE (n2:Musico {nome: 'Bob Dylan'})
Somente um nó é inserido no banco - este comando também serve para os relacionamentos
arquivos csv podem ser importados no neo4j
$ LOAD CSV WITH HEADERS FROM "file:///composicoes.csv" AS linha
MERGE (compositor:Musico {nome: linha.compositor}) 
MERGE (musica:Musica {nome: linha.musica}) 
MERGE (compositor)-[:COMPOS]->(musica)

$LOAD CSV WITH HEADERS
FROM "file:///gravacoes.csv"
AS linha
MERGE (interprete:Musico {nome: linha.interprete})
MERGE (musica:Musica {nome: linha.musica})
MERGE (interprete)-[:GRAVOU]->(musica)

 

CRIANDO SCRIPTS NEO4J PART II
Consultar músicos que gravaram músicas
MATCH (i:Musico)-[g:GRAVOU]->(m:Musica) RETURN i, m



Exercício: Retorne todos os compositores e musicas que o Bon Jovi gravou
Meu:
MATCH (bon:Musico {nome: 'Jon Bon Jovi'})-[r:GRAVOU]->(m:Musica)
MATCH (com:Musico)-[s:COMPOS]->(m:Musica)
RETURN com, m
Professor:
MATCH (interprete:Musico)-[gravou:GRAVOU]->(musica:Musica)
MATCH (compositor:Musico)-[compos:COMPOS]->(music:Musica)
WHERE interprete.nome = "Jon Bon Jovi"
RETURN interprete, musica, compositor

Neo4J Python

Recomendações em sites de compras é muito bom para BD grafos
Redes sociais (relacionamentos entre entidades com um desempenho maior e com volumes de dados huge)

Replicação no Neo4j
Cluster 1 Master -> N Slaves
Todos são leitura e escrita
escreve no Master, replica para os demais
se escrever no slave, copia para o master, replica para os demais
Alta disponibilidade  --- no entanto, por ser baseado em nós conectados, não permite a distribuição 
dos nós em diferentes clusters (baixa escalabilidade)

quando usar = 
dados conectados (funcionários, clientes, hierarquia)
serviços de localização
sistema de recomendação

quando não usar = 
quando há muita alteração (update nas propriedades dos nós)
problemas que lidam com grafos inteiros (se todo mundo se relaciona com todo mundo, então não é bom)